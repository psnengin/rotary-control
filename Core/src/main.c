/*******************************************************************************
*     Filename:   main.c
*   Created on:   2022.05.12
*       Author:   Сергей П.
 *******************************************************************************
*  Description:   Программа предназначена для формирования управляющего воздей-
*                 ствия в зависимости от угла поворота акселерометра в осях XY.
*                 Может использоваться для  диммера, термостата и т.д.
*                 *************************************************************
*                 Реализует опрос акселерометра LIS2DH12 по шине I2C, по преры-
*                 ванию от сигнала готовности акселерометра.

*                 Режим WORK_STATE :
*                 Акселерометр настроен на измерения с интервалом 100мс. При
*                 поступлении новых данных в выходные регистры, датчик формирует
*                 сигнал  низкого уровня на выходе INT1. Задний фронт этого сиг-
*                 нала обрабатывается на входе PA0 микроконтроллера как прерыва-
*                 ние,  которое запускает следующие процедуры:
*                  * опроса датчика по шине I2C,
*                  * контроль допустимого отклонения плоскости XY от вертикали,
*                  * расчет угла поворота акселерометра в осях XY,
*                  * формирование и передачу сигнала управления модулю ШИМ,
*                  * контроль наличия управляющего воздействия (крутят или нет).
*                 После чего микроконтроллер переводится в режим энергопотребле-
*                 ния sleep до следующего сигнала от датчика или переходит в ре-
*                 жим  SLEEP_STATE, если положение акселерометра не изменялось
*                 заданное количество циклов измерений.

*                 Режим SLEEP_STATE :
*                 Акселерометр настроен на ожидание движения. Формирует
*                 сигнал прерывания только при изменении положения.
*                 Микроконтроллер находится в режиме энергопотребления sleep.
*                 При поступлении сигнала от датчика переходит в режим WORK_STATE.
*                 Сторожевой таймер (WWDT) настроен на сброс через 262 мс.
*                 Перезагрузка  WWDT происходит после каждого цикла измерений в
*                 режиме WORK_STATE и в прерывании от таймера TIM14 в режиме
*                 SLEEP_STATE.
*******************************************************************************
* Контроллер:     stm32030f4p6  (16 Kb Flash,  4Kb RAM )
*                 PA0    вход прерывания от акселерометра (задний фронт)
*                 PA6    выход ШИМ (активный уровень высокий)
*                 PA9    I2C SCL (внешняя подтяжка к плюсу питания)
*                 PA10   I2C SDA (внешняя подтяжка к плюсу питания)
*
* Датчик:         lis2dh12 трехосевой акселерометр
*                 INT1   выход прерывания,  соединение с PA0
*                 SCL    I2C SCL,           соединение с PA9
*                 SDA    I2C SDA,           соединение с PA10
*                 CS     внешняя подтяжка к плюсу питания
*                 SA0	 внешняя подтяжка к плюсу питания				
*******************************************************************************
*/

#include <stm32f030x6.h>                  /*файл регистров периферии контроллера*/
#include "accel_lis2dh.h"                 /*работа с акселерометром, расчет угла*/
#include "init.h"                         /*инициализация периферии при старте*/
#include "irq.h"                          /*обработчики прерываний*/
#include "error.h"                        /*обработчик ошибок*/
#include "i2c.h"                          /*чтение/запись по I2C */


#define WORK_STATE           (1U)         /*основное состояние кон. автомата*/
#define SLEEP_STATE          (2U)         /*состояние покоя*/

#define REST_DETECTED        (1U)         /*датчик неподвижен, готовить переход в SLEEP_STATE*/
#define REST_NOT_DETECTED    (0U)         /*датчик движется оставаться в WORK_STATE*/
#define REST_DET_CNT_MAX     (50U)        /*кол-во одинаковых измерений подряд для REST_DETECTED*/
                                         
#define NULL_ZONE            (10U)        /*зона без регулировки (+-NULL_ZONE) градусов от 0*/

extern uint8_t flag_pa0_irq;              /*флаг прерывания PA0, объявлен в irq.c*/


void  StateMachine (void);                /*автомат состояний*/
uint8_t  RestDedect (uint16_t angle);     /*определение отсутствия движения*/
void  OutControl (uint16_t angle);        /*управление выходом ШИМ в зависимости от угла поворота*/

/*
********************************************************************************
*/

int main()
{
    uint16_t error_glob = 0;

    InitStart();                                             /*инициализация периферии контроллера*/
    do                                                       
    {                                                        /*инициализация датчика*/
        error_glob = AccSetWkSt();                           /*запись параметров датчика*/
        if (error_glob != 0) {ErrHandler (error_glob);}      /*запись прошла с ошибкой*/
    } while (error_glob != 0);                               /*повторять пока не запишется без ошибок или WWDT Reset*/

    while(1)                                                 /*основной цикл*/
    {
        StateMachine();                                      /*автомат состояний*/
        WWDG->CR  = WWDG_REFRESH;                            /*перезапуск WWDT*/
        __WFI();                                             /*перевести контроллер в режим энергопотребления sleep*/
    }
}
/*
********************************************************************************
* Функция  - автомат состояний, переключает режимы WORK_STATE и SLEEP_STATE.
* тактируется прерыванием по входу PA0
* ******************************************************************************
*/
void  StateMachine (void)
{
    uint16_t error_glob = 0;
    static uint8_t state = WORK_STATE;      /*состояние конечного автомата*/
    static uint16_t alfa = 0;               /*угол поворота в градусах [0-360]*/


    if (flag_pa0_irq == IRQ_PA0_FLAG_ON)                                 /*заходить по прерыванию PA0*/
    {
        switch (state)                                                   /*автомат состояний*/
        {
            case WORK_STATE:
            {
                 alfa = AccRdAngle();                                     /*получить угол от акселерометра*/
                 OutControl(alfa);                                        /*передать управляющее воздействие*/

                 if (RestDedect(alfa) == REST_DETECTED)                   /*нет движения*/
                 {
                     do
                     {
                         error_glob = AccSetSlSt();                        /*запись параметров датчика*/
                         if (error_glob != 0) {ErrHandler (error_glob);}   /*запись прошла с ошибкой*/
                     } while (error_glob != 0);                            /*повторять пока не запишется без ошибок или WWDT Reset*/

                     NVIC_EnableIRQ(TIM14_IRQn);                           /*разрешить прерывания от таймера TIM14,*/
                                                                           /*в нем перезагружается WWDT когда система в SLEEP_STATE */

                     state = SLEEP_STATE;                                  /*перейти в SLEEP_STATE*/
                 }
             } break;  
                 
            case SLEEP_STATE:
            {
                 error_glob = 0;
                 do
            	 {
                     error_glob = AccSetWkSt();                            /*запись параметров датчика*/
                     if (error_glob != 0) {ErrHandler (error_glob);}       /*запись прошла с ошибкой*/
            	 } while (error_glob != 0);                                /*повторять пока не запишется без ошибок или WWDT Reset*/

                 NVIC_DisableIRQ(TIM14_IRQn);                              /*запретить прерывание от таймера TIM14 в WORK_STATE*/

                 state = WORK_STATE;                                       /*переключить состояние на рабочее*/
             }  break;               
            default:
                break;
        }
        flag_pa0_irq = IRQ_PA0_FLAG_OFF;                                   /*сбросить флаг прерывания*/
    }
	else{};
}
/*
********************************************************************************
* Функция определяет отсутствие движения акселерометра за REST_DET циклов
* измерения.
* ******************************************************************************
* param[in]    angle  		 : значение угла поворота акселерометра в осях XY
* [out]        REST_DETECTED     : нет  движения - пора в SLEEP_STATE
*              REST_NOT_DETECTED : есть движение - остаться в WORK_STATE
* ******************************************************************************
 */
uint8_t  RestDedect (uint16_t angle)
{
    static uint16_t last_angle = 0;        /*угол из предидущего измерения*/
    static uint16_t rest_cnt   = 0;        /*счетчик циклов с неизменным значением*/
    uint16_t delta = 0;                    /*разница между текущим и предидущим значением*/


    if (last_angle > angle) {delta = last_angle - angle;}       /*модуль delta*/
    else                    {delta = angle - last_angle;}

    if ((delta <= 2) || (angle == 0) || (angle == 360))         /*критерии покоя*/
    {
        if (rest_cnt >= REST_DET_CNT_MAX)
        {
            rest_cnt = 0;
            return REST_DETECTED;
        }
        else
        {
            rest_cnt++;
        }
    }
    else
    {
        last_angle = angle;                                     /*если дельта >2*/
        rest_cnt   = 0;
    }

    return REST_NOT_DETECTED;
}

/*
********************************************************************************
* Функция осуществляет управление выходом ШИМ в зависимости от угла поворота.
* (0 +- NULL_ZONE)градусов область без регулировки - коэф. заполнения ШИМ = 0.
* при угле поворота равном  NULL_ZONE начинается регулирование,
* при угле равном (360 - NULL_ZONE) коэф. заполнения ШИМ максимальный.
* Смотри настройки ШИМ в функции init_TIM3(), файл init.c
* ******************************************************************************
* param[in]    angle :   значение угла поворота акселерометра в осях XY
* ******************************************************************************
*/

void  OutControl (uint16_t angle)
{
    uint32_t control_output = 0;                               /*выходное воздействие*/

    if ((angle > (360 - NULL_ZONE)) || (angle < NULL_ZONE))    /*зона без регулировки*/
    {
        control_output = 0;
    }
    else
    {
    	angle = angle - NULL_ZONE;
    	control_output = (((uint32_t) angle) * angle) >> 4;    /*квадратичная зависимость для яркости*/
                                                               /*расчет значения TIM3->ARR = 7225*/
                                                               /*при NULL_ZONE = 10,   360-20=340 - диапазон углов*/
                                                               /* 340 * 340 /16 = 7225  */
    }
        TIM3->CCR1 = (uint16_t)control_output;                 /*отправить в таймер ШИМ*/
}

/*end file*/
