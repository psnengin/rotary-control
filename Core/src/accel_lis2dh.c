/*******************************************************************************
*    Filename:   accel_lis2dh.c
*  Created on:   2022.05.12
*      Author:   Сергей П.
* Description:   взаимодействие с акселерометром LIS2DH12
********************************************************************************
*/

#include <stm32f030x6.h>
#include "error.h"
#include "i2c.h"


/*максимальное значение проекции g на ось z при котором происходит регулировка ШИМ*/
/*максимальный угол отклонения  arcsin(ZMAX/1g) 1g=16384; ( 4240 = угол 15град)*/

#define ZMAX              (8192)           /*+-30 градусов*/

/*Количество байт считываемых из датчика в каждом цикле измерений*/
#define XYZ_READ_NB       (7U)
                                                      

uint8_t  AccTabCotan (int32_t ctg);
uint16_t  AccTrigonom (int32_t x, int32_t y);

/*
********************************************************************************
* Функция конфигурирует акселерометр LIS2DH для состояния SLEEP_STATE.
* Производит контроль записи.
* После конфигурации акселерометр производит измерения по осям XYZ с частотой 10Гц,
* убирает постоянную составляющую сигнала, при внешнем воздействии больше поро-
* гового  формирует сигнал низкого уровня на выходе INT1
* ******************************************************************************
* [out]   код ошибки
* ******************************************************************************
*/
 uint16_t AccSetSlSt (void)
{
    uint16_t err	= 0;                    /*возвращаемый код ошибки*/
    const uint8_t acc_cnf_slst [6][2] =     /*acc_cnf_slst[0][0] = address,  acc_cnf_slst[0][1] = data*/
               {
                 {0x20,    0b00000000},     /*CTRL_REG1: power down mode*/
                 {0x20,    0b00100111},     /*CTRL_REG1: HiRes, 10Hz, оси XYZ разрешить*/
                 {0x21,    0b10001001},     /*CTRL_REG2: отфильтр. пост сигнал, IA1*/
                 {0x32,    0b00000100},     /*INT1_THS : 2g порог 16*8=128*/
                 {0x22,    0b01000000},     /*CTRL_REG3: INT1 IA1 interrupt*/
                 {0x30,    0b00101010}      /*INT1_CFG : разрешить прерывание XYZ*/
               };


    for (uint8_t i = 0; i<=5; i++)
    {
        err = I2cWrVrByte (LIS2DH_ADDR, acc_cnf_slst [i][0], acc_cnf_slst [i][1]);
        if (err != 0) {return err;}
    }
    return err;
}

/*
********************************************************************************
* Функция конфигурирует акселерометр LIS2DH для состояния WORK_STATE.
* Производит контроль записи.
* После конфигурации акселерометр производит измерения по осям XYZ с частотой
* 10Гц, при  готовности данных формирует сигнал низкого уровня на выходе INT1.
* ******************************************************************************
* [out]   код ошибки
* ******************************************************************************
 */
uint16_t AccSetWkSt(void)
{
    uint16_t err = 0;                    /*возвращаемый код ошибки*/
    const uint8_t acc_cnf_wkst [9][2] =  /*acc_cnf_wkst[0][0] = address,  acc_cnf_wkst[0][1] = data*/
            {
             {0x20, 0b00000000},         /*CTRL_REG1: power down mode*/
             {0x30, 0b00000000},         /*INT1_CFG : запретить прерывание XYZ*/
             {0x1e, 0b00010000},         /*CTRL_REG0: bit4 =1 всегда*/
             {0x21, 0b00000000},         /*CTRL_REG2: фильтр отключить*/
             {0x22, 0b00010000},         /*CTRL_REG3: INT1 ZYXDA interrupt*/
             {0x23, 0b00001000},         /*CTRL_REG4: +-2g,high resolution*/
             {0x24, 0b00000000},         /*CTRL_REG5: INT не защелкивать*/
             {0x25, 0b00000010},         /*CTRL_REG6: активный уровень INT1-низкий*/
             {0x20, 0b00100111}          /*CTRL_REG1: HiRes, 10Hz, оси XYZ разрешить*/
            };


    for (uint8_t i = 0; i <= 8; i++)
    {
    err = I2cWrVrByte (LIS2DH_ADDR, acc_cnf_wkst [i][0], acc_cnf_wkst [i][1]);
    if (err != 0) {return err;}
    }
    return err;
}

/*
********************************************************************************
* функция получает данные с акселерометра, возвращает угол в градусах [0-360]
* ******************************************************************************
* [out]   [0 - 360]  :значение угла в плоскости XY
* ******************************************************************************
 */
uint16_t  AccRdAngle (void)
{

    uint16_t error_glob = 0;     /*ошибка*/
    int16_t x_val       = 0;     /*значение по оси X*/
    int16_t y_val       = 0;     /*значение по оси Y*/
    int16_t z_val       = 0;     /*значение по оси Z*/

    uint32_t xyz_data[XYZ_READ_NB] = {0};            /*в этот массив считываются данные из акселерометра*/

    static struct I2cBufStruct xyz_rd_st;                                    /*создать экземпляр структуры*/

    xyz_rd_st.slaveAddress        = LIS2DH_ADDR;                             /*адрес опрашиваемого slave устройства на шине I2C, <=127*/
    xyz_rd_st.startRegisterAdress = LIS2DH_OUT_X_L|(1<<7);                   /*[0-6]бит адрес регистра, [7]бит=1 автоинкремент адреса*/
    xyz_rd_st.numberBytes         = sizeof(xyz_data)/sizeof(xyz_data[0]);    /*количество последовательно считываемых байт*/
    xyz_rd_st.buffer              = xyz_data;                                /*ссылка на массив размерностью numberBytes*/

    do
    {
        error_glob = I2cRdDma (xyz_rd_st);      /*прочесть данные с датчика*/
        if (error_glob != 0)
        {
            ErrHandler (error_glob);            /*обработать ошибку*/
        }
     } while (error_glob != 0);                 /*ждать пока прочтет без ошибок или WWDT reset*/

    z_val |= xyz_data[5] << 8;                  /*получить значение по оси Z*/
    z_val |= xyz_data[4];

    if ((z_val < ZMAX) && (z_val > (-ZMAX)))    /*если плоскость XY отклонена от вертикали не больше ZMAX*/
    {
        x_val |= xyz_data[1]<<8;                /*получить значение по оси X*/
        x_val |= xyz_data[0];

        y_val |= xyz_data[3]<<8;                /*получить значение по оси Y*/
        y_val |= xyz_data[2];

        return AccTrigonom((int32_t) x_val, (int32_t) y_val);   /* расчет угла*/
    }
    else
    {
        return 0;                                /*если отклонение от вертикали больше ZMAX*/
    }
}

/*
********************************************************************************
* функция выполняет действие arcctg т.е. возвращает значение угла по его котан-
* генсу, с точностью до целых значений градуса. Содержит массив значений котан-
* генса угла от 0 до 45 градусов, умноженных на 512.
* angle == arcctg (tab[angle]/512), где angle - целое значение угла в градусах.
* Например: ctg (45) = 1,  1*512=512,  это 45 член массива tab[45]=512.
* ******************************************************************************
* param[in]    ctg       :котангенс угла умноженный на 512
* [out]        [0 - 45]  :значение угла в градусах соответствующее ctg
* ******************************************************************************
*/
uint8_t AccTabCotan (int32_t ctg)
{
    const int32_t tab[46] ={65535,  29332,  14662,  9770,  7322,  5852,
                                     4871,   4170,  3643,  3233,  2904,
                                     2634,   2409,  2218,  2054,  1911,
                                     1786,   1675,  1576,  1487,  1407,
                                     1334,   1267,  1206,  1150,  1098,
                                     1050,   1005,   963,   924,   887,
                                      852,    819,   788,   759,   731,
                                      705,    679,   655,   632,   610,
                                      589,    569,   549,   530,   512};

    uint8_t serch_flag = 0;      /*флаг точного совпадения со значением в массиве*/
    int8_t  left       = 0;      /*левая граница поиска, начальный элемент tab[0]*/
    int8_t  right      = 45;     /*правая граница поиска, начальный элемент tab[45]*/
    int8_t  middle     = 0;      /*середина диапазона поиска*/


    while ((left <= right) && (serch_flag !=1 ))   /*бинарный поиск близкого значения*/
    {
        middle = (left + right) / 2;
        if (ctg > tab[middle])
        {
            right = middle - 1;
        }
        else if (ctg < tab[middle])
             {
                 left = middle + 1;
             }
             else
             {
                 serch_flag = 1;
             }
    }
    return middle;
}
/*
********************************************************************************
* функция преобразует проекцию g на оси X и Y в угол поворота в плоскости XY,
* целочисленный аналог функции atan2(y,x).
* ******************************************************************************
*param[in]    x          :проекция g на ось X
*param[in]    y          :проекция g на ось Y
*[out]        [0 - 360]  :значение угла в градусах в плоскости XY
* ******************************************************************************
 */
uint16_t  AccTrigonom (int32_t x, int32_t  y)
{
    uint16_t xyAngle=0;   /*угол в градусах  в плоскости xy от оси x против  часовой стрелки*/

  
    if      (y == 0 && x > 0)  {return 0;}                /*исключить x=0, y=0*/
    else if (x == 0 && y > 0)  {return 90;}
    else if (y == 0 && x < 0)  {return 180;}
    else if (x == 0 && y < 0)  {return 270;}
    else if (y == 0 && x == 0) {return 0;}   

    if (y > 0)                               /*делим плоскость xy на квадранты*/                                  
    {
        if (x > 0)                                                              /*1 квадрант*/
        {
            if (x > y)           {xyAngle = AccTabCotan((x << 9) / y);}         /*0-45, (x << 9) x*512*/
            else                 {xyAngle = 90 - AccTabCotan((y << 9) / x);}    /*45 -90*/
        }
        else if (x < 0)                                                         /*2 квадрант*/
             {
                 x = (-x);                                                      /*модуль x*/
                 if (y > x)      {xyAngle = 90  + AccTabCotan((y << 9) / x);}   /*90-135*/
                 else            {xyAngle = 180 - AccTabCotan((x << 9) / y);}   /*135-180*/
             }
    }
    else if (y<0)
	 {
             y=(-y);
             if (x < 0)                                                         /*3 квадрант*/
             {
                 x=(-x);
                 if (x > y)      {xyAngle = 180 + AccTabCotan((x<<9)/y);}       /*180-225*/
                 else            {xyAngle = 270 - AccTabCotan((y<<9)/x);}       /*225-270*/
             }
             else if (x > 0)                                                    /*4 квадрант*/
                  {
                      if (y > x) {xyAngle = 270 + AccTabCotan((y<<9)/x);}       /*270-315*/
                      else       {xyAngle = 360 - AccTabCotan((x<<9)/y);}       /*315-360*/
                  }
        }
        return xyAngle;
}

/*end file*/







